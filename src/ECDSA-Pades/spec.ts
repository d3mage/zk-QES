import path from 'node:path';
import { fileURLToPath } from 'node:url';
import type { Noir } from '@noir-lang/noir_js';
import type { Barretenberg, UltraHonkBackend as BarretenbergBackend } from '@aztec/bb.js';
import { extractSignatureFromPDF } from './signature.ts';
import type { RunSpec, ProofResult } from '../common/runner.ts';
import {
    type CommonPreparationResult,
    padMerklePath,
    prepareCommon,
    verifyProofCommon,
    writeProofArtifacts
} from '../common/pades.ts';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..', '..');
const DEFAULT_MODE = 'pedersen';

type PreparationResult = CommonPreparationResult & {
    pub_key_x: Uint8Array;
    pub_key_y: Uint8Array;
    signature: Uint8Array;
};

type EcdsaManifest = {
    version: number;
    signed_attrs_hash: string;
    signer: {
        pub_x: string;
        pub_y: string;
        fingerprint: string;
    };
    tl_root: string;
    proof: string;
    timestamp: string;
    notes: string;
};

type EcdsaProofResult = ProofResult<EcdsaManifest>;

export type EcdsaSpecOptions = {
    pdfPath: string;
    allowlistPath?: string;
    allowlistCertPaths?: string[];
    circuitPath?: string;
    outDir?: string;
    mode?: string;
    isDump?: boolean;
};

async function preparePDF(
    pdfPath: string,
    allowlistPath: string,
    mode: string,
    isDump: boolean = false,
    outDir: string = 'out',
    bbApi?: Barretenberg,
    allowlistCertPaths?: string[],
): Promise<PreparationResult> {
    return prepareCommon({
        pdfPath,
        allowlistPath,
        allowlistCertPaths,
        mode,
        isDump,
        outDir,
        bbApi,
        extractLabel: 'ECDSA',
        extract: async (pdfBuffer, extractOutDir, extractDump) => {
            const extractedData = await extractSignatureFromPDF(pdfBuffer, extractOutDir, extractDump);
            const signature = Buffer.concat([extractedData.signature.r, extractedData.signature.s]);

            return {
                signedAttrsHash: extractedData.signedAttrsHash,
                certificate: extractedData.certificate,
                pub_key_x: extractedData.publicKey.x,
                pub_key_y: extractedData.publicKey.y,
                signature: new Uint8Array(signature),
            };
        },
    });
}

async function generateProof(
    prep: PreparationResult,
    noir: Noir,
    backend: BarretenbergBackend,
    isDump: boolean = false,
    outDir: string = 'out',
): Promise<EcdsaProofResult> {
    console.log('\n=== Proof Generation Phase ===\n');

    const signed_attrs_hash = prep.signed_attrs_hash;

    console.log('Inputs:');
    console.log(`  signed_attrs_hash: ${Buffer.from(signed_attrs_hash).toString('hex')}`);
    console.log(`  pub_key_x: ${Buffer.from(prep.pub_key_x).toString('hex')}`);
    console.log(`  pub_key_y: ${Buffer.from(prep.pub_key_y).toString('hex')}`);
    console.log(`  signer_fpr: ${prep.signer_fpr} (Field)`);
    console.log(`  tl_root: ${prep.tl_root} (Field)`);
    console.log(`  index: ${prep.index}`);
    console.log(`  signature: ${Buffer.from(prep.signature).toString('hex')}`);

    const merkle_path = padMerklePath(prep.merkle_path, 8);

    const noirInputs = {
        signed_attrs_hash: Array.from(signed_attrs_hash),
        pub_key_x: Array.from(prep.pub_key_x),
        pub_key_y: Array.from(prep.pub_key_y),
        signer_fpr: prep.signer_fpr,
        tl_root: prep.tl_root,
        signature: Array.from(prep.signature),
        merkle_path,
        index: prep.index,
    };

    console.log('\nGenerating witness...');
    const { witness } = await noir.execute(noirInputs);

    console.log('Generating proof...');
    const proof = await backend.generateProof(witness);

    console.log(`✓ Proof generated (${proof.proof.length} bytes)`);

    const vkey = await backend.getVerificationKey();

    const manifest: EcdsaManifest = {
        version: 1,
        signed_attrs_hash: Buffer.from(signed_attrs_hash).toString('hex'),
        signer: {
            pub_x: Buffer.from(prep.pub_key_x).toString('hex'),
            pub_y: Buffer.from(prep.pub_key_y).toString('hex'),
            fingerprint: prep.signer_fpr_hex,
        },
        tl_root: prep.tl_root,
        proof: Buffer.from(proof.proof).toString('base64'),
        timestamp: new Date().toISOString(),
        notes: 'Generated by runner',
    };

    if (isDump) {
        writeProofArtifacts({
            outDir,
            proof: proof.proof,
            publicInputs: proof.publicInputs,
            vkey,
            manifest,
        });
    }

    console.log('\n✓ Proof generation complete.');

    return {
        proof: proof.proof,
        publicInputs: proof.publicInputs,
        vkey,
        manifest,
    };
}

async function verifyProof(
    proofResult: EcdsaProofResult,
    backend: BarretenbergBackend,
    expectedTlRoot?: string,
): Promise<boolean> {
    return verifyProofCommon(proofResult, backend, expectedTlRoot, (manifest) => {
        console.log(`  Version: ${manifest.version}`);
        console.log(`  Timestamp: ${manifest.timestamp}`);
        console.log(`  Signed attrs hash: ${manifest.signed_attrs_hash}`);
        console.log(`  Signer fingerprint: ${manifest.signer.fingerprint}`);
    });
}

export function createEcdsaRunSpec(options: EcdsaSpecOptions): RunSpec<PreparationResult, EcdsaProofResult> {
    const mode = options.mode ?? DEFAULT_MODE;
    const outDir = options.outDir ?? path.join(__dirname, 'out');
    const allowlistPath = options.allowlistPath ?? path.join(outDir, 'allowlist.generated.json');

    return {
        id: 'ecdsa',
        label: `ECDSA PAdES (${mode})`,
        mode,
        isDump: options.isDump ?? false,
        paths: {
            pdfPath: options.pdfPath,
            allowlistPath,
            circuitPath: options.circuitPath ?? path.join(repoRoot, 'circuits', `pades_ecdsa_${mode}`),
            outDir,
        },
        prepare: (pdfPath, allowlistPath, mode, isDump, outDir, bbApi) =>
            preparePDF(pdfPath, allowlistPath, mode, isDump, outDir, bbApi, options.allowlistCertPaths),
        generateProof,
        verifyProof,
    };
}
