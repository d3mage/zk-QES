#!/usr/bin/env node
/**
 * Generate Prover.toml for nargo from extracted data
 */

import fs from 'node:fs';
import path from 'node:path';
import crypto from 'node:crypto';

async function main() {
    const outDir = 'out';

    // Load all inputs (same as prove.ts)
    const docHashPath = path.join(outDir, 'VERIFIED_signed_attrs_hash.bin');
    let message_for_sig: Uint8Array;

    if (fs.existsSync(docHashPath)) {
        message_for_sig = new Uint8Array(fs.readFileSync(docHashPath));
    } else {
        message_for_sig = new Uint8Array(fs.readFileSync(path.join(outDir, 'doc_hash.bin')));
    }

    const pubkeyJson = JSON.parse(fs.readFileSync(path.join(outDir, 'VERIFIED_pubkey.json'), 'utf-8'));
    const pub_key_x = Buffer.from(pubkeyJson.x, 'hex');
    const pub_key_y = Buffer.from(pubkeyJson.y, 'hex');

    const certPem = fs.readFileSync(path.join(outDir, 'cms_embedded_cert.pem'), 'utf-8');
    const base64Content = certPem
        .replace(/-----BEGIN CERTIFICATE-----/, '')
        .replace(/-----END CERTIFICATE-----/, '')
        .replace(/\s/g, '');
    const certDer = Buffer.from(base64Content, 'base64');
    const signer_fpr_bytes = crypto.createHash('sha256').update(certDer).digest();
    const signer_fpr_hex = signer_fpr_bytes.toString('hex');
    const signer_fpr = BigInt('0x' + signer_fpr_hex).toString();

    const tlRootPath = path.join(outDir, 'tl_root_poseidon.txt');
    const tl_root = fs.readFileSync(tlRootPath, 'utf-8').trim();

    const proofPath = path.join(outDir, 'paths-poseidon', `${signer_fpr_hex}.json`);
    const proofData = JSON.parse(fs.readFileSync(proofPath, 'utf-8'));
    const merkle_path = proofData.merkle_path_decimal || [];
    while (merkle_path.length < 8) {
        merkle_path.push('0');
    }
    const index = proofData.index.toString();

    const sigJsonPath = path.join(outDir, 'VERIFIED_sig.json');
    const sigJson = JSON.parse(fs.readFileSync(sigJsonPath, 'utf-8'));
    const signature = Buffer.concat([
        Buffer.from(sigJson.r, 'hex'),
        Buffer.from(sigJson.s, 'hex')
    ]);

    // Generate Prover.toml
    const toml = `# Generated by generate-prover-toml.ts
doc_hash = [${Array.from(message_for_sig).join(', ')}]
pub_key_x = [${Array.from(pub_key_x).join(', ')}]
pub_key_y = [${Array.from(pub_key_y).join(', ')}]
signer_fpr = "${signer_fpr}"
tl_root = "${tl_root}"
eu_trust_enabled = false
tl_root_eu = "0"
signature = [${Array.from(signature).join(', ')}]
merkle_path = ["${merkle_path.join('", "')}"]
index = "${index}"
eu_merkle_path = ["0", "0", "0", "0", "0", "0", "0", "0"]
eu_index = "0"
`;

    const proverTomlPath = 'circuits/pades_ecdsa_hybrid/Prover.toml';
    fs.writeFileSync(proverTomlPath, toml);
    console.log(`âœ… Generated ${proverTomlPath}`);
    console.log(`\nYou can now run:`);
    console.log(`  cd circuits/pades_ecdsa_hybrid && nargo execute`);
}

main().catch(err => {
    console.error('Error:', err.message);
    process.exit(1);
});
