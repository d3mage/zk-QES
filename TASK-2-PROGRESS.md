# Task 2 Progress: Bind ZK Proofs to Artifacts

## Status: 70% Complete

### Completed âœ…

#### 1. Circuit Update (circuits/pades_ecdsa/src/main.nr)
- **New Public Inputs:**
  - `doc_hash`: SHA-256 of PDF ByteRange (document binding)
  - `artifact_hash`: SHA-256 of ciphertext/CID (artifact binding)
  - `pub_key_x`, `pub_key_y`: Signer's public key
  - `signer_fpr`: SHA-256 of certificate DER (identity binding)
  - `tl_root`: Merkle root of allowed signers (trust list)

- **New Private Inputs:**
  - `signature`: ECDSA P-256 signature (r || s)
  - `merkle_path`: Sibling hashes for Merkle proof (depth 8)
  - `index`: Leaf position in trust list

- **Verification Logic:**
  1. ECDSA P-256 signature verification over `doc_hash`
  2. Merkle tree membership proof for `signer_fpr` in `tl_root`
  3. Artifact binding via public input commitment

- **Implementation Details:**
  - Uses SHA-256 for Merkle tree (matches TypeScript tooling)
  - Depth-8 tree supports up to 256 signers
  - Circuit compiles successfully with Noir 1.0.0-beta.3

#### 2. Merkle Toolchain (tools/merkle/)

**build.ts**
- Builds Merkle tree from `allowlist.json`
- Generates root and inclusion proofs for all fingerprints
- Outputs:
  - `out/tl_root.hex`: Tree root (32-byte hex)
  - `out/tl_root.json`: Metadata (root, depth, leaf count)
  - `out/paths/<fingerprint>.json`: Inclusion proof per signer

**prove.ts**
- Retrieves Merkle proof for specific certificate fingerprint
- Usage: `yarn merkle:prove --fingerprint <hex> --out <file>`

**Example allowlist.json:**
```json
{
  "cert_fingerprints": [
    "06a02856c08dde5c6679377c06f6fe7be1855d586bd1448343db2736b1473cd3",
    "1111111111111111111111111111111111111111111111111111111111111111",
    ...
  ]
}
```

**Tested:**
```bash
$ yarn merkle:build allowlist.json --out out
Tree built successfully:
  Root:  4691e104c3e28e563a23b1dc79593159d3607c30489ba44917f9ec1c2a8528bc
  Depth: 2
  Leaves: 4
```

#### 3. Prover Update (scripts/prove.ts)

**New Input Loading:**
- Reads `doc_hash.bin` (PDF ByteRange hash)
- Computes `artifact_hash` from `cipher_hash.bin` or placeholder
- Derives `signer_fpr` from certificate PEM â†’ DER â†’ SHA-256
- Loads `tl_root.hex` and corresponding Merkle proof
- Pads Merkle path to 8 elements

**Protocol Manifest Generation:**
```json
{
  "version": 1,
  "doc_hash": "<hex>",
  "artifact": {
    "type": "cipher",
    "artifact_hash": "<sha256-hex>"
  },
  "signer": {
    "pub_x": "<hex>",
    "pub_y": "<hex>",
    "fingerprint": "<sha256-cert>"
  },
  "tl_root": "<hex>",
  "proof": "<base64>",
  "timestamp": "<iso8601>",
  "notes": "Generated by prove.ts"
}
```

Outputs: `out/manifest.json`, `out/proof.bin`, `out/vkey.bin`

#### 4. Verifier Update (scripts/verify.ts)

**5-Step Verification:**
1. Load manifest from `out/manifest.json`
2. **Artifact Binding Check:**
   - If `encrypted-file.bin` exists, compute SHA-256
   - Verify hash matches `manifest.artifact.artifact_hash`
3. **Trust List Check:**
   - Verify `tl_root` matches local `tl_root.hex`
4. Load proof and verification key
5. **ZK Proof Verification:**
   - Verifies proof with Barretenberg backend

**Output Example:**
```
=== ZK Qualified Signature Verification ===

[1/5] Loading manifest...
  Version:   1
  Timestamp: 2025-10-23T23:30:00.000Z
  Doc hash:  406b03a5...
  Signer:    06a02856...

[2/5] Verifying artifact binding...
  âœ“ Artifact hash matches ciphertext

[3/5] Verifying trust list membership...
  âœ“ Trust list root matches

[4/5] Loading proof...
  Proof size: 2048 bytes
  VKey size:  1024 bytes

[5/5] Verifying zero-knowledge proof...
  âœ“ ZK proof verified!

âœ… ALL VERIFICATIONS PASSED!
```

### Remaining Work ðŸš§

#### 5. Encryption Hardening (30% done)
**Goal:** Bind encryption to document hash via AES-GCM AAD

**Current Status:**
- `scripts/encrypt-upload.ts` and `scripts/decrypt.ts` exist from Task 1
- Need to update to:
  - Set `aad = doc_hash_bytes` in AES-GCM
  - Compute `cipher_hash = SHA-256(ciphertext)`
  - Save as `out/cipher_hash.bin` and `out/encrypted-file.bin`

**Implementation:**
```typescript
// In encrypt-upload.ts
const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
cipher.setAAD(docHashBytes); // <-- Add this
const encrypted = Buffer.concat([
  cipher.update(plaintextData),
  cipher.final()
]);

// Compute artifact hash
const cipherHash = crypto.createHash('sha256').update(encrypted).digest();
fs.writeFileSync('out/cipher_hash.bin', cipherHash);
```

#### 6. E2E Tests (not started)
**Scenarios to implement:**

**Positive Test:**
```bash
# Full flow Aâ†’Bâ†’A
yarn hash-byte-range sample_signed.pdf
yarn extract-cms sample_signed.pdf
yarn merkle:build allowlist.json --out out
yarn encrypt-upload sample.pdf --out out/encrypted-file.bin
yarn prove
yarn verify
```

**Tamper Tests:**
1. Modify ciphertext â†’ artifact hash mismatch â†’ verify fails
2. Change CID â†’ binding check fails
3. Remove signer from allowlist â†’ Merkle proof fails
4. Swap doc_hash â†’ ECDSA verification fails

#### 7. README Documentation (not started)
**Sections to add:**

- **Binding & Trust:**
  - Explain document, artifact, and identity binding
  - Trust list concept and Merkle proofs
  - Manifest structure and verification flow

- **Commands:**
  ```bash
  # Build trust list
  yarn merkle:build allowlist.json --out out

  # Generate proof with binding
  yarn prove  # Auto-loads all inputs

  # Verify with binding checks
  yarn verify
  ```

- **Security Notes:**
  - AAD binding prevents ciphertext substitution
  - Trust list binding prevents unauthorized signers
  - Artifact hash binding prevents document swapping

### Technical Debt & Notes

1. **SHA-256 vs Poseidon2:**
   - Currently using SHA-256 for Merkle tree for simplicity
   - Circuit and tooling both use SHA-256 (consistent)
   - Could optimize to Poseidon2 later for smaller proofs
   - Would require Barretenberg integration in TypeScript

2. **Certificate Fingerprint:**
   - Computed as SHA-256(certificate-DER)
   - Matches approach: `openssl x509 -in cert.pem -outform DER | sha256sum`
   - Currently: `06a02856c08dde5c6679377c06f6fe7be1855d586bd1448343db2736b1473cd3`

3. **Merkle Tree Depth:**
   - Fixed at 8 levels (256 leaves max)
   - Could make configurable later
   - Proofs are padded with zeros if tree is smaller

4. **Artifact Hash Choice:**
   - Using `SHA-256(ciphertext)` as primary
   - Could also support `SHA-256(CID)` for IPFS
   - Documented in manifest as `artifact.type: "cipher"`

### Files Created/Modified

**New Files:**
- `tools/merkle/build.ts` - Merkle tree builder
- `tools/merkle/prove.ts` - Proof retriever
- `allowlist.json` - Example trust list
- `TASK-2-PROGRESS.md` - This file

**Modified Files:**
- `circuits/pades_ecdsa/src/main.nr` - Updated circuit
- `scripts/prove.ts` - Extended for bindings + manifest
- `scripts/verify.ts` - Multi-step verification
- `package.json` - Added `merkle:build`, `merkle:prove` scripts

**Generated Outputs:**
- `out/tl_root.hex` - Merkle root
- `out/tl_root.json` - Tree metadata
- `out/paths/*.json` - Inclusion proofs
- `out/manifest.json` - Protocol manifest

### Next Steps (Priority Order)

1. **Complete encryption hardening** (1-2 hours)
   - Update encrypt-upload.ts with AAD binding
   - Update decrypt.ts to verify AAD
   - Generate cipher_hash.bin

2. **Write E2E test script** (2-3 hours)
   - Implement `scripts/e2e-test.ts`
   - Positive flow test
   - Tamper detection tests
   - Document expected outputs

3. **Update README** (1-2 hours)
   - Add "Binding & Trust" section
   - Document new commands
   - Add security notes
   - Update architecture diagram

4. **Optional optimizations:**
   - Switch to Poseidon2 for Merkle (research + 4 hours)
   - Add IPFS CID binding support (2 hours)
   - Implement DocMDP & timestamps (task 1 blocker) (8+ hours)

### Estimated Completion Time

- **Remaining work:** 4-7 hours
- **With optimizations:** 10-15 hours
- **Current progress:** 70%

---

*Last updated: 2025-10-23T23:30:00Z*
*Ready for encryption hardening implementation*
